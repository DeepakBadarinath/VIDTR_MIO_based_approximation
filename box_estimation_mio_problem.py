# -*- coding: utf-8 -*-
"""
Box_estimation_MIO_problem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QqCns-OhNhUOMXlP_NFt4iq__6lLFUGG

Solve the following equation:

$ ((\hat{a}_1, \hat{b}_1), (\hat{a}_2, \hat{b}_2), ..., (\hat{a}_q, \hat{b}_q)) := \arg_{a_1, a_2, ..., a_q} \min_{b_1, b_2, ..., b_q} \sum_{i=1}^n U^l_{iat} \mathcal{I}[(X[i,1] \in [a_1,b_1]),  (X[i,2] \in [a_2,b_2]), (X[i,3] \in [a_3,b_3]) ...  (X[i,q] \in [a_q, b_q])] $

*   In the above, we have that: $U^{l}_{iat} := [\max_{\alpha} [r_t(X_{it}), \alpha) + \gamma P^{\alpha}_t V_{t+1}(X_{it})] - [r_t(X_{it},a) + \gamma P^a_t V^I_{t+1}(X_{it})]] \mathcal{I}[X_{it} \not \in G^{l-1}_t]$

* $z_i := \mathcal{I}[X_{it} \in R]$, which we can split and write as:
    * $\mathcal{I}[X_{it} \in R] := \Pi_{j=1}^d \mathcal{I}[a_j - M(1-z_i) \leq (X_{it})_j \leq b_j + M(1-z_i)]$

* We write the above as MIP problem as follows:
    * $\arg_{z_i \in {0,1}} \min_{b_i > a_i} \sum_{i=1}^N z_i U_i$
    * Subject to $ a_j - M(1-z_i) \leq x_{ij} \leq b_j + M(1-z_i)$ $\forall i \in [N], j \in [q]$

* We solve the above problem using the Gurobi solver.
"""
#%%

import gurobipy as gp
from gurobipy import GRB
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from mpl_toolkits.mplot3d import Axes3D
from gurobipy import Model, GRB
from gurobipy import quicksum, GRB

#%%
import gurobipy as gp
print(gp.gurobi.version())



#%%

def solve_mip_with_box(U, X, M=10000, lambda_reg=0.0):
    
    if len(X.shape) == 3:
        X = np.reshape(X, (X.shape[0], X.shape[1]))
    
    N, q = X.shape
    model = Model()
    model.setParam("OutputFlag", 0)

    z = model.addVars(N, vtype=GRB.BINARY, name="z")
    a = model.addVars(q, lb=-GRB.INFINITY, name="a")
    b = model.addVars(q, lb=-GRB.INFINITY, name="b")

    for j in range(q):
        model.addConstr(b[j] >= a[j] + 1e-3, name=f"box_margin_{j}")

    for i in range(N):
        for j in range(q):
            xij = float(X[i, j])  # Convert to scalar float
            model.addConstr(xij >= a[j] - M * (1 - z[i]), name=f"lb_{i}_{j}")
            model.addConstr(xij <= b[j] + M * (1 - z[i]), name=f"ub_{i}_{j}")


    U = np.asarray(U, dtype=float).ravel()
    X = np.asarray(X, dtype=float)

    # Objective
    model.setObjective(
        quicksum(U[i] * z[i] for i in range(N)) +
        float(lambda_reg) * quicksum(b[j] - a[j] for j in range(q)),
        GRB.MINIMIZE
    )
    
    model.optimize()

    selected = [i for i in range(N) if z[i].X >= 0.5]
    a_sol = np.array([a[j].X for j in range(q)])
    b_sol = np.array([b[j].X for j in range(q)])
    return selected, a_sol, b_sol, model.ObjVal

def visualize_selection(X, U, selected, a, b):
    q = X.shape[1]
    if q == 2:
        _plot_2d(X, U, selected, a, b)
    elif q == 3:
        _plot_3d(X, U, selected, a, b)

def _plot_2d(X, U, selected, a, b):
    plt.figure(figsize=(8, 6))
    colors = ['green' if u < 0 else 'red' for u in U]
    plt.scatter(X[:, 0], X[:, 1], c=colors, edgecolors='k', s=80)
    for i, (x, y) in enumerate(X):
        plt.text(x + 0.1, y, f"{U[i]}", fontsize=8)
    if selected:
        plt.scatter(X[selected, 0], X[selected, 1], color='blue', s=100, label='Selected')

    rect = patches.Rectangle((a[0], a[1]), b[0] - a[0], b[1] - a[1],
                             linewidth=2, edgecolor='black', facecolor='none', label='Box')
    plt.gca().add_patch(rect)
    plt.title("2D MIP Selection")
    plt.legend()
    plt.grid(True)
    plt.axis('equal')
    plt.show()

def _plot_3d(X, U, selected, a, b):
    fig = plt.figure(figsize=(10, 7))
    ax = fig.add_subplot(111, projection='3d')
    colors = ['green' if u < 0 else 'red' for u in U]
    ax.scatter(X[:, 0], X[:, 1], X[:, 2], c=colors, s=60, edgecolors='k')
    if selected:
        ax.scatter(X[selected, 0], X[selected, 1], X[selected, 2], c='blue', s=100, label='Selected')

    # draw bounding box
    from itertools import product
    corners = np.array(list(product(*zip(a, b))))
    for i in range(8):
        for j in range(i+1, 8):
            d = np.abs(corners[i] - corners[j])
            if np.count_nonzero(d) == 1:
                ax.plot(*zip(corners[i], corners[j]), color="black", linewidth=1)

    ax.set_xlabel("x₁")
    ax.set_ylabel("x₂")
    ax.set_zlabel("x₃")
    ax.set_title("3D MIP Selection")
    plt.legend()
    plt.show()